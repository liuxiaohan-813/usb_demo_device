#include "usb.h"
#include "scsi.h"

uint8_t *pEp1SendData;
uint32_t Ep1DataLength;

int Ep2DataLength;

uint32_t ByteAddr;

uint8_t TransportStage;
#define COMMAND_STAGE 0x01
#define DATA_STAGE    0x02
#define STATUS_STAGE  0x03

#define EP1_SIZE 0x200
#define EP2_SIZE 0x200
uint8_t Ep2Buffer[EP2_SIZE];

extern uint8_t CBW[31];
extern uint8_t CSW[13];

//#define UPAN_READ_ONLY

const uint8_t DiskInf1[36] = {
    0x00, // 磁盘设备
    0x80, // 其中最高位D7为RMB。RMB=0，表示不可移除设备。如果RMB=1，则为可移除设备
    0x00, // 各种版本号0
    0x01, // 数据响应格式
    0x1F, // 附加数据长度，为31字节
    0x00, 0x00, 0x00, // 保留

    0x4D, 0x61, 0x73, 0x73, // 厂商标识
    0x20, 0x20, 0x20, 0x20,

    0x53, 0x74, 0x6F, 0x72, // 产品标识
    0x61, 0x67, 0x65, 0x20,
    0x44, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x20, 0x20,
    0x31, 0x2E, 0x30, 0x30
};

const uint8_t MaximumCapacity[12]=
{
    0x00, 0x00, 0x00, // 保留
    0x08,             // 容量列表长度
    0x01, 0x00, 0x00, 0x00, // 块数(最大支持8GB)
    0x03,                   // 描述符代码为3，表示最大支持的格式化容量
    0x00, 0x02, 0x00        // 每块大小为512字节
};

const uint8_t DiskCapacity[8]=
{
    0x00, 0x03, 0xFF, 0xFF, // 能够访问的最大逻辑块地址
    0x00, 0x00, 0x02, 0x00  // 块的长度
    // 所以该磁盘的容量为 (0x3FFFF + 1) * 0x200 = 128MB
};

//DBR（DOS引导记录）
const uint8_t Dbr[512]=
{
    0xeb, 0x3e, 0x90,          //跳转指令，不能改为0，否则提示未格式化
    'M','S','D','O','S','5','.','0', //文件系统及版本信息"MSDOS5.0"
    0x00, 0x02,                //每扇区字节数，为512字节
    0x20,                      //每簇扇区数，为32扇区
    0x01, 0x00,                //保留扇区数，为1
    0x02,                      //该分区的FAT份数，为2
    0x00, 0x02,                //根目录项数，为512项
    0x00, 0x00,                //小扇区数，这里不用，为0
    0xF8,                      //媒体描述符，0xF8表示硬盘
    0x20, 0x00,                //每FAT扇区数，为32个
    0x20, 0x00,                //每道扇区数，为32
    0x40, 0x00,                //磁头数为64
    0x00, 0x00, 0x00, 0x00,    //隐藏扇区数这里没有隐藏扇区，为0
    0x00, 0x00, 0x04, 0x00,    //大扇区数，扇区的总数，128M为0x40000
    0x80,                      //磁盘驱动器参数，80表示硬盘
    0x00,                      //保留
    0x29,                      //扩展引导标记，0x29表示接下来的三个域可用
    0x88, 0x09, 0x71, 0x20,    //标卷序列号

    // 磁盘标卷
    0xC8, 0xA6, 0xC8, 0xA6, 0xB5, 0xC4, 0xBC, 0xD9,
    0x55, 0xC5, 0xCC,

    // 文件系统类型信息，为字符串"FAT16   "
    'F', 'A', 'T', '1', '6', 0x20, 0x20, 0x20,

    //以下为引导代码，直接从其它U盘复制而来
    0xf1, 0x7d,
    0xfa, 0x33, 0xc9, 0x8e,  0xd1, 0xbc, 0xfc, 0x7b,  0x16, 0x07, 0xbd, 0x78,  0x00, 0xc5, 0x76, 0x00,
    0x1e, 0x56, 0x16, 0x55,  0xbf, 0x22, 0x05, 0x89,  0x7e, 0x00, 0x89, 0x4e,  0x02, 0xb1, 0x0b, 0xfc,
    0xf3, 0xa4, 0x06, 0x1f,  0xbd, 0x00, 0x7c, 0xc6,  0x45, 0xfe, 0x0f, 0x8b,  0x46, 0x18, 0x88, 0x45,
    0xf9, 0xfb, 0x38, 0x66,  0x24, 0x7c, 0x04, 0xcd,  0x13, 0x72, 0x3c, 0x8a,  0x46, 0x10, 0x98, 0xf7,
    0x66, 0x16, 0x03, 0x46,  0x1c, 0x13, 0x56, 0x1e,  0x03, 0x46, 0x0e, 0x13,  0xd1, 0x50, 0x52, 0x89,
    0x46, 0xfc, 0x89, 0x56,  0xfe, 0xb8, 0x20, 0x00,  0x8b, 0x76, 0x11, 0xf7,  0xe6, 0x8b, 0x5e, 0x0b,
    0x03, 0xc3, 0x48, 0xf7,  0xf3, 0x01, 0x46, 0xfc,  0x11, 0x4e, 0xfe, 0x5a,  0x58, 0xbb, 0x00, 0x07,
    0x8b, 0xfb, 0xb1, 0x01,  0xe8, 0x94, 0x00, 0x72,  0x47, 0x38, 0x2d, 0x74,  0x19, 0xb1, 0x0b, 0x56,
    0x8b, 0x76, 0x3e, 0xf3,  0xa6, 0x5e, 0x74, 0x4a,  0x4e, 0x74, 0x0b, 0x03,  0xf9, 0x83, 0xc7, 0x15,
    0x3b, 0xfb, 0x72, 0xe5,  0xeb, 0xd7, 0x2b, 0xc9,  0xb8, 0xd8, 0x7d, 0x87,  0x46, 0x3e, 0x3c, 0xd8,
    0x75, 0x99, 0xbe, 0x80,  0x7d, 0xac, 0x98, 0x03,  0xf0, 0xac, 0x84, 0xc0,  0x74, 0x17, 0x3c, 0xff,
    0x74, 0x09, 0xb4, 0x0e,  0xbb, 0x07, 0x00, 0xcd,  0x10, 0xeb, 0xee, 0xbe,  0x83, 0x7d, 0xeb, 0xe5,
    0xbe, 0x81, 0x7d, 0xeb,  0xe0, 0x33, 0xc0, 0xcd,  0x16, 0x5e, 0x1f, 0x8f,  0x04, 0x8f, 0x44, 0x02,
    0xcd, 0x19, 0xbe, 0x82,  0x7d, 0x8b, 0x7d, 0x0f,  0x83, 0xff, 0x02, 0x72,  0xc8, 0x8b, 0xc7, 0x48,
    0x48, 0x8a, 0x4e, 0x0d,  0xf7, 0xe1, 0x03, 0x46,  0xfc, 0x13, 0x56, 0xfe,  0xbb, 0x00, 0x07, 0x53,
    0xb1, 0x04, 0xe8, 0x16,  0x00, 0x5b, 0x72, 0xc8,  0x81, 0x3f, 0x4d, 0x5a,  0x75, 0xa7, 0x81, 0xbf,
    0x00, 0x02, 0x42, 0x4a,  0x75, 0x9f, 0xea, 0x00,  0x02, 0x70, 0x00, 0x50,  0x52, 0x51, 0x91, 0x92,
    0x33, 0xd2, 0xf7, 0x76,  0x18, 0x91, 0xf7, 0x76,  0x18, 0x42, 0x87, 0xca,  0xf7, 0x76, 0x1a, 0x8a,
    0xf2, 0x8a, 0x56, 0x24,  0x8a, 0xe8, 0xd0, 0xcc,  0xd0, 0xcc, 0x0a, 0xcc,  0xb8, 0x01, 0x02, 0xcd,
    0x13, 0x59, 0x5a, 0x58,  0x72, 0x09, 0x40, 0x75,  0x01, 0x42, 0x03, 0x5e,  0x0b, 0xe2, 0xcc, 0xc3,
    0x03, 0x18, 0x01, 0x27,  0x0d, 0x0a, 0x49, 0x6e,  0x76, 0x61, 0x6c, 0x69,  0x64, 0x20, 0x73, 0x79,
    0x73, 0x74, 0x65, 0x6d,  0x20, 0x64, 0x69, 0x73,  0x6b, 0xff, 0x0d, 0x0a,  0x44, 0x69, 0x73, 0x6b,
    0x20, 0x49, 0x2f, 0x4f,  0x20, 0x65, 0x72, 0x72,  0x6f, 0x72, 0xff, 0x0d,  0x0a, 0x52, 0x65, 0x70,
    0x6c, 0x61, 0x63, 0x65,  0x20, 0x74, 0x68, 0x65,  0x20, 0x64, 0x69, 0x73,  0x6b, 0x2c, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x74,  0x68, 0x65, 0x6e, 0x20,  0x70, 0x72, 0x65, 0x73,  0x73, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x6b, 0x65,  0x79, 0x0d, 0x0a, 0x00,  0x49, 0x4f, 0x20, 0x20,  0x20, 0x20, 0x20, 0x20,
    0x53, 0x59, 0x53, 0x4d,  0x53, 0x44, 0x4f, 0x53,  0x20, 0x20, 0x20, 0x53,  0x59, 0x53, 0x80, 0x01,
    0x00, 0x57, 0x49, 0x4e,  0x42, 0x4f, 0x4f, 0x54,  0x20, 0x53, 0x59, 0x53,  0x00, 0x00, 0x55, 0xaa,
};

// 模拟的文件分配表
// 其中项0为0xFFF8，项1为0xFFFF，表示已经使用。
// 项2为0xFFFF，表示文件结束。其余项为0，表示未使用
const uint8_t Fat[64]=
{
    0xF8, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00
};

const uint8_t Zeros[64]=
{
    0x00,
};

// 测试文件的数据
const uint8_t TestFileData[20]=
{
    "hello, Upan"
};

#define TIME_HB(H,M,S) ((((((H)<<11))|((M)<<5)|(S))>>8) & 0xFF)
#define TIME_LB(H,M,S) (((((H)<<11))|((M)<<5)|(S)) & 0xFF)
#define DATE_HB(Y,M,D) ((((((Y)-1980)<<9)|((M)<<5)|(D))>>8) & 0xFF)
#define DATE_LB(Y,M,D) (((((Y)-1980)<<9)|((M)<<5)|(D)) & 0xFF)
const uint8_t RootDir[64]=
{
    0xD0, 0xBE, 0xC0, 0xB4, 0xC4, 0xA3, 0xC4, 0xE2, 0x55, 0xC5, 0xCC,
    0x08,
    0x00,
    0x00,

    TIME_LB(15,27,35), TIME_HB(15,27,35),
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    DATE_LB(2008,8,20), DATE_HB(2008,8,20),
    0x00, 0x00,

    TIME_LB(15,36,47), TIME_HB(15,36,47),

    DATE_LB(2008,8,19), DATE_HB(2008,8,19),

    0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,

    'T',  'E',   'S',  'T', ' ', ' ', ' ', ' ',  'T', 'X', 'T',
    0x01,
    0x00,
    0x00,

    TIME_LB(15,48,26), TIME_HB(15,48,26),

    DATE_LB(2008,8,19), DATE_HB(2008,8,19),

    DATE_LB(2008,8,20), DATE_HB(2008,8,20),

    0x00, 0x00,

    TIME_LB(15,50,33), TIME_HB(15,50,33),

    DATE_LB(2008,8,19), DATE_HB(2008,8,19),

    0x02, 0x00,

    (sizeof(TestFileData)-1) & 0xFF,((sizeof(TestFileData) - 1) >> 8) & 0xFF, 0x00, 0x00,
};

const uint8_t SenseData[18]=
{
    0x70,
    0x00,
    0x05,
    0x00, 0x00, 0x00, 0x00,
    0x0A,
    0x00, 0x00, 0x00, 0x00,
    0x24,
    0x00,
    0x00, 0x00, 0x00, 0x00
};

#ifdef UPAN_READ_ONLY
const uint8_t BulkBuf[4] = {0x3, 0, 0x80, 0};
#else
const uint8_t BulkBuf[4] = {0x3, 0, 0x0, 0};
#endif

uint32_t GetDataTransferLength(void)
{
    uint32_t Len;

    Len = CBW[11] << 24 | CBW[10] << 16 | CBW[9] << 8 | CBW[8];

    return Len;
}

uint32_t GetLba(void)
{
    uint32_t Lba;

    Lba = CBW[17] << 24 | CBW[18] << 16 | CBW[19] << 8 | CBW[20];

    return Lba;
}

void SetCsw(uint32_t Residue, uint8_t Status)
{
    CSW[0] = 'U';
    CSW[1] = 'S';
    CSW[2] = 'B';
    CSW[3] = 'S';

    CSW[4] = CBW[4];
    CSW[5] = CBW[5];
    CSW[6] = CBW[6];
    CSW[7] = CBW[7];

    CSW[8] = Residue & 0xFF;
    CSW[9] = (Residue >> 8) & 0xFF;
    CSW[10] = (Residue >> 16) & 0xFF;
    CSW[11] = (Residue >> 24) & 0xFF;

    CSW[12] = Status;
}

void GetDiskData(void)
{
    if (ByteAddr == 0) pEp1SendData = (uint8_t *)Dbr;
    if (ByteAddr == 512) pEp1SendData = (uint8_t *)Fat;
    if ((ByteAddr >= 576) && (ByteAddr < 16896)) pEp1SendData = (uint8_t *)Zeros;
    if (ByteAddr == 16896) pEp1SendData = (uint8_t *)Fat;
    if ((ByteAddr >= 16960) && (ByteAddr < 33280)) pEp1SendData = (uint8_t *)Zeros;
    if (ByteAddr == 33280) pEp1SendData = (uint8_t *)RootDir;
    if ((ByteAddr >= 33344) && (ByteAddr < 49664)) pEp1SendData = (uint8_t *)Zeros;
    if (ByteAddr == 49664) pEp1SendData = (uint8_t *)TestFileData;
    if (ByteAddr > 50175) pEp1SendData = (uint8_t *)Zeros;

    ByteAddr += EP1_SIZE;
}

void Ep1SendData(void)
{

    uint32_t len;
    /* status stage */
    if (TransportStage == STATUS_STAGE) {
        if (Ep1DataLength == 0) {
            FIFOWrite(1, sizeof(CSW), CSW);
            TransportStage = COMMAND_STAGE;
            return;
        }
    }
    if (TransportStage == DATA_STAGE) {
        /* data stage */
        if (Ep1DataLength > EP1_SIZE) {
            len = EP1_SIZE;
            Ep1DataLength -= len;
        } else {
            len = Ep1DataLength;
            Ep1DataLength = 0;
        }
        FIFOWrite(1, len, pEp1SendData);
        pEp1SendData += len;
        if (Ep1DataLength == 0) {
            TransportStage = STATUS_STAGE;
        }
    }
}

void ProcScsiCommand(void)
{
    printf("SCSI CMD is 0x%x \r\n", CBW[15]);
    TransportStage = COMMAND_STAGE;
    switch (CBW[15]) {
        case INQUIRY:
            printf("SCSI INQUIRY\r\n");
            pEp1SendData = (uint8_t *)DiskInf1;
            Ep1DataLength = GetDataTransferLength();
            if (Ep1DataLength > sizeof(DiskInf1)) {
                SetCsw(Ep1DataLength - sizeof(DiskInf1), 0);
            } else {
                SetCsw(0, 0);
            }
            if (Ep1DataLength > sizeof(DiskInf1)) {
                Ep1DataLength = sizeof(DiskInf1);
            }
            TransportStage = DATA_STAGE;
        break;

        case READ_FORMAT_CAPACITIES:
            printf("SCSI READ_FORMAT_CAPACITIES\r\n");
            pEp1SendData = (uint8_t *)MaximumCapacity;
            Ep1DataLength = GetDataTransferLength();
            if (Ep1DataLength > sizeof(MaximumCapacity)) {
                SetCsw(Ep1DataLength - sizeof(MaximumCapacity), 0);
            } else {
                SetCsw(0, 0);
            }
            if (Ep1DataLength > sizeof(MaximumCapacity)) {
                Ep1DataLength = sizeof(MaximumCapacity);
            }
            TransportStage = DATA_STAGE;
        break;

        case READ_CAPACITY:
            printf("scsi READ_CAPACITY\r\n");
            pEp1SendData = (uint8_t *)DiskCapacity;
            Ep1DataLength = GetDataTransferLength();
            if (Ep1DataLength > sizeof(DiskCapacity)) {
                SetCsw(Ep1DataLength - sizeof(DiskCapacity), 0);
            } else {
                SetCsw(0, 0);
            }
            if (Ep1DataLength > sizeof(DiskCapacity)) {
                Ep1DataLength = sizeof(DiskCapacity);
            }
            TransportStage = DATA_STAGE;
        break;

        case READ_10:
            printf("SCSI READ(10)\r\n");
            Ep1DataLength = GetDataTransferLength();
            ByteAddr = GetLba() * 512;
            SetCsw(0, 0);
            GetDiskData();
            TransportStage = DATA_STAGE;
        break;

        case WRITE_10:
            printf("SCSI WRITE(10)\r\n");
            Ep2DataLength = GetDataTransferLength();
            SetCsw(0, 0);
            //TransportStage = STATUS_STAGE;
        break;

        case REQUEST_SENSE:
            printf("SCSI REQUEST SENSE\r\n");
            pEp1SendData = (uint8_t *)SenseData;
            Ep1DataLength = GetDataTransferLength();
            if (Ep1DataLength > sizeof(SenseData)) {
                SetCsw(Ep1DataLength - sizeof(SenseData), 0);
            } else {
                SetCsw(0, 0);
            }
            if (Ep1DataLength > sizeof(SenseData)) {
                Ep1DataLength = sizeof(SenseData);
            }
            TransportStage = DATA_STAGE;
        break;

        case TEST_UNIT_READY:
            Ep1DataLength = 0;
            SetCsw(0, 0);
            TransportStage = STATUS_STAGE;
        break;

        case ModeSense_6:
            pEp1SendData = BulkBuf;
            Ep1DataLength = sizeof(BulkBuf);
            SetCsw(0, 0);
            printf("SCSI MODE SENSE6\r\n");
            TransportStage = DATA_STAGE;
        break;
        case PREV_ALLOW_REMOVE:
            printf("SCSI PREV_ALLOW_REMOVE send stall\r\n");
            Ep1DataLength = 0;
            SetCsw(0, 0);
            TransportStage = STATUS_STAGE;
        break;
        default: // 其它命令不认，返回执行失败
            Ep1DataLength = 0;
            SetCsw(GetDataTransferLength() - Ep1DataLength, 1); // 设置CSW为失败
            TransportStage = STATUS_STAGE;
        break;
    }

    Ep1SendData();
}

void ProcScsiOutData(void)
{
    uint16_t length;

    length = REG32(USB_COM_CFG_BASE + 0x120 + 0x40 * 2); // Rx FIFO size

    FIFORead(2, length, Ep2Buffer);
    Ep2DataLength -= length;

    if (Ep2DataLength <= 0) {
        Ep1DataLength = 0;
        TransportStage = STATUS_STAGE;
        SetCsw(0, 0);
        // Ep1SendData();
    }

}